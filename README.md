# SolidPrincipleConcepts

- `S` -> Single Responsibility Principle (Classes/functions/packages/variables should have only
        1 reason to change / 1 responsibility)
- `O` -> Open/Closed Principle (Open for extension but closed for modification)
- `L` -> Liskov Substitution Principle (If class B is a subtype of class A, then we should be able to replace the object 
        of A with B without breaking the behaviour of the program)

        -+-+-+-+-+- Subclass should extend the capability of parent not narrow it down -+-+-+-+-+-
- `I` -> Interface Segregation Principle (Interfaces shouldn't force classes to implement what they can't do. Large
        interfaces should be divided into smaller ones)
- `D` -> Dependency Inversion Principle (Class should depend on abstractions(interfaces) rather than concrete classes)


## Advantages

- `Clean`: SOLID principles make code clean and standard code.
- `Maintainable`: with the help of SOLID principles our code becomes more manageable and easy to maintain.
- `Scalable`: Easy to refactor or change code.
- `Redundancy`: SOLID principles avoid redundant code.
- `Testable`: can be easily unit tested.
- `Readable`: SOLID principles make the code easy and readable.
- `Independent`: code becomes independent by reducing dependencies.
- `Reusable`: code becomes reusable.

